// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include <Rcpp.h>

using namespace Rcpp;

#ifdef RCPP_USE_GLOBAL_ROSTREAM
Rcpp::Rostream<true>&  Rcpp::Rcout = Rcpp::Rcpp_cout_get();
Rcpp::Rostream<false>& Rcpp::Rcerr = Rcpp::Rcpp_cerr_get();
#endif

// GetMatrix
NumericMatrix GetMatrix(std::vector<std::vector<int>> m);
RcppExport SEXP _tRiad_GetMatrix(SEXP mSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::vector<std::vector<int>> >::type m(mSEXP);
    rcpp_result_gen = Rcpp::wrap(GetMatrix(m));
    return rcpp_result_gen;
END_RCPP
}
// Edge
int Edge(int I, int J, std::vector<std::vector<int>> e);
RcppExport SEXP _tRiad_Edge(SEXP ISEXP, SEXP JSEXP, SEXP eSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< int >::type I(ISEXP);
    Rcpp::traits::input_parameter< int >::type J(JSEXP);
    Rcpp::traits::input_parameter< std::vector<std::vector<int>> >::type e(eSEXP);
    rcpp_result_gen = Rcpp::wrap(Edge(I, J, e));
    return rcpp_result_gen;
END_RCPP
}
// LeftRight
double LeftRight(double Px, double Py, double Ax, double Ay, double Bx, double By);
RcppExport SEXP _tRiad_LeftRight(SEXP PxSEXP, SEXP PySEXP, SEXP AxSEXP, SEXP AySEXP, SEXP BxSEXP, SEXP BySEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< double >::type Px(PxSEXP);
    Rcpp::traits::input_parameter< double >::type Py(PySEXP);
    Rcpp::traits::input_parameter< double >::type Ax(AxSEXP);
    Rcpp::traits::input_parameter< double >::type Ay(AySEXP);
    Rcpp::traits::input_parameter< double >::type Bx(BxSEXP);
    Rcpp::traits::input_parameter< double >::type By(BySEXP);
    rcpp_result_gen = Rcpp::wrap(LeftRight(Px, Py, Ax, Ay, Bx, By));
    return rcpp_result_gen;
END_RCPP
}
// Swap
bool Swap(double x1, double y1, double x2, double y2, double x3, double y3, double xp, double yp);
RcppExport SEXP _tRiad_Swap(SEXP x1SEXP, SEXP y1SEXP, SEXP x2SEXP, SEXP y2SEXP, SEXP x3SEXP, SEXP y3SEXP, SEXP xpSEXP, SEXP ypSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< double >::type x1(x1SEXP);
    Rcpp::traits::input_parameter< double >::type y1(y1SEXP);
    Rcpp::traits::input_parameter< double >::type x2(x2SEXP);
    Rcpp::traits::input_parameter< double >::type y2(y2SEXP);
    Rcpp::traits::input_parameter< double >::type x3(x3SEXP);
    Rcpp::traits::input_parameter< double >::type y3(y3SEXP);
    Rcpp::traits::input_parameter< double >::type xp(xpSEXP);
    Rcpp::traits::input_parameter< double >::type yp(ypSEXP);
    rcpp_result_gen = Rcpp::wrap(Swap(x1, y1, x2, y2, x3, y3, xp, yp));
    return rcpp_result_gen;
END_RCPP
}
// TriLoc
int TriLoc(int i, std::vector<double> x, std::vector<double> y, std::vector<std::vector<int>> v, std::vector<std::vector<int>> e);
RcppExport SEXP _tRiad_TriLoc(SEXP iSEXP, SEXP xSEXP, SEXP ySEXP, SEXP vSEXP, SEXP eSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< int >::type i(iSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type x(xSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type y(ySEXP);
    Rcpp::traits::input_parameter< std::vector<std::vector<int>> >::type v(vSEXP);
    Rcpp::traits::input_parameter< std::vector<std::vector<int>> >::type e(eSEXP);
    rcpp_result_gen = Rcpp::wrap(TriLoc(i, x, y, v, e));
    return rcpp_result_gen;
END_RCPP
}
// Delaun
NumericMatrix Delaun(NumericVector norm_x, NumericVector norm_y);
RcppExport SEXP _tRiad_Delaun(SEXP norm_xSEXP, SEXP norm_ySEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< NumericVector >::type norm_x(norm_xSEXP);
    Rcpp::traits::input_parameter< NumericVector >::type norm_y(norm_ySEXP);
    rcpp_result_gen = Rcpp::wrap(Delaun(norm_x, norm_y));
    return rcpp_result_gen;
END_RCPP
}
// NewTriad
List NewTriad(NumericVector x, NumericVector y, NumericMatrix v);
RcppExport SEXP _tRiad_NewTriad(SEXP xSEXP, SEXP ySEXP, SEXP vSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< NumericVector >::type x(xSEXP);
    Rcpp::traits::input_parameter< NumericVector >::type y(ySEXP);
    Rcpp::traits::input_parameter< NumericMatrix >::type v(vSEXP);
    rcpp_result_gen = Rcpp::wrap(NewTriad(x, y, v));
    return rcpp_result_gen;
END_RCPP
}
// DelTri
RObject DelTri(RObject x_, RObject y_);
RcppExport SEXP _tRiad_DelTri(SEXP x_SEXP, SEXP y_SEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< RObject >::type x_(x_SEXP);
    Rcpp::traits::input_parameter< RObject >::type y_(y_SEXP);
    rcpp_result_gen = Rcpp::wrap(DelTri(x_, y_));
    return rcpp_result_gen;
END_RCPP
}

static const R_CallMethodDef CallEntries[] = {
    {"_tRiad_GetMatrix", (DL_FUNC) &_tRiad_GetMatrix, 1},
    {"_tRiad_Edge", (DL_FUNC) &_tRiad_Edge, 3},
    {"_tRiad_LeftRight", (DL_FUNC) &_tRiad_LeftRight, 6},
    {"_tRiad_Swap", (DL_FUNC) &_tRiad_Swap, 8},
    {"_tRiad_TriLoc", (DL_FUNC) &_tRiad_TriLoc, 5},
    {"_tRiad_Delaun", (DL_FUNC) &_tRiad_Delaun, 2},
    {"_tRiad_NewTriad", (DL_FUNC) &_tRiad_NewTriad, 3},
    {"_tRiad_DelTri", (DL_FUNC) &_tRiad_DelTri, 2},
    {NULL, NULL, 0}
};

RcppExport void R_init_tRiad(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
