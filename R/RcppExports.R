# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

GetMatrix <- function(m) {
    .Call(`_triad_GetMatrix`, m)
}

#' @title Implementation of the EDG subroutine
#' @description Returns which edge of I is adjacent to J
#' @param I index of triangles I
#' @param J index of triangle J
#' @param e List of adjacent triangles
Edge <- function(I, J, e) {
    .Call(`_triad_Edge`, I, J, e)
}

#' @title Cross Product of AB and AP
#' @description Calculates cross product of AP and AP to check if P is left or right of AB
#' @param Px X component of point P
#' @param Py Y component of point P
#' @param Ax X component of point A
#' @param Ay Y component of point A
#' @param Bx X component of point B
#' @param By Y component of point B
#' @importFrom Rcpp evalCpp
#' @exportPattern ^[[:alpha:]]+
#' @useDynLib triad, .registration=TRUE
#' @export
LeftRight <- function(Px, Py, Ax, Ay, Bx, By) {
    .Call(`_triad_LeftRight`, Px, Py, Ax, Ay, Bx, By)
}

#'@title Implementation of the SWAP subroutine
#'@description Checks to see if triangle P-V2-V1 and V3-V1-V2 need to swap common edge
#'@param x1 X coordinate of V1
#'@param y1 Y coordinate of V1
#'@param x2 X coordinate of V2
#'@param y2 Y coordinate of V2
#'@param x3 X coordinate of V3
#'@param y3 Y coordinate of V3
#'@param xp X coordinate of P
#'@param yp Y coordinate of P
#'@export
Swap <- function(x1, y1, x2, y2, x3, y3, xp, yp) {
    .Call(`_triad_Swap`, x1, y1, x2, y2, x3, y3, xp, yp)
}

#'@title Check which triangles a point lies within
#'@description Returns the index of the triangle which contains the given point
#'@param i index of the point to be located
#'@param x X coordinates of points
#'@param y Y coordinates of points
#'@param v Vertices of triangles, columns are triangle number and rows are vertices 1,2,3
#'@param e Adjacency of triangles, columns are triangle number and rows are ids of adjacent triangles
#'@export
TriLoc <- function(i, x, y, v, e) {
    .Call(`_triad_TriLoc`, i, x, y, v, e)
}

#'@export
test_TriLoc <- function(i, x, y, v, e) {
    .Call(`_triad_test_TriLoc`, i, x, y, v, e)
}

#'@title Implementation of the DELAUN subroutine
#'@description Returns a Delaunay Triangulation but with normalised points
#'@param norm_x Normalised X coordinates of points
#'@param norm_y Normalised Y coordinates of points
#'@export
Delaun <- function(norm_x, norm_y) {
    .Call(`_triad_Delaun`, norm_x, norm_y)
}

timesTwo <- function(x) {
    .Call(`_triad_timesTwo`, x)
}

