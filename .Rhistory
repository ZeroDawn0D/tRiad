devtools::check()
devtools::use_gpl3_license()
??use_gpl3_license()
usethis::use_gpl3_license()
devtools::check()
install.packages("devtools", "roxygen2")
install.packages("devtools")
devtools::check()
point <- function(x1 = 0, y1 = 0, z1 = 0){
value <- list(x = x1, y = y1, z = z1)
class(value) = "point"
}
p1 <- function()
{}
a <- point()
a$x
point <- function(x1 = 0, y1 = 0, z1 = 0){
value <- list(x = x1, y = y1, z = z1)
class(value) = "point"
value
}
a <- point()
a$x
$y
a$y
a$z
b <- point(1,2)
b$x
b$y
b$z
b
test <- list(bruh = "lmao")
class(test) = "point"
test
rm(list = ls())
test
point <- function(x1 = 0, y1 = 0, z1 = 0){
value <- list(x = x1, y = y1, z = z1)
class(value) = "point"
value
}
p1 <- point(1,2)
class(p1)
p0 <- point()
p1
p0
class(point)
crossprod(p0,p1)
point <- function(x1 = 0, y1 = 0, z1 = 0){
value <- matrix(x = x1, y = y1, z = z1)
class(value) = "point"
value
}
p0 <- point()
point <- function(x1 = 0, y1 = 0, z1 = 0){
value <- vector(x = x1, y = y1, z = z1)
class(value) = "point"
value
}
p0 <- point()
rm(list = ls())
p0 <- vector(1,1,0)
p0 <- c(1,1,0)
p1 <- c(-1,1,0)
crossprod(p0,p1)
rm(list = ls())
vector3D <- function(x = 0, y = 0, z = 0){
value <- c(x,y,z)
class(value) = "vector3D"
value
}
p <- vector3D
p1 <- vector3D()
p1
p1[0]
p1[1]
p1[2]
p1[3]
p1$x
class(p1)
p1
p1[0]
p1[8]
test <- c(1,43,5,25,2)
test[0]
test[-1]
test
ls()
rm(list = ls())
t <- factor(c("a","b","c"))
class(t)
typeof(t)
vector3D <- function(x1 = 0, y1 = 0, z1 = 0){
value <- list(x = x1, y = y1, z = z1)
class(value) = "vector3D"
value
}
p <- vector3D()
is.object(p)
class(p)
typeof(p)
p1 <- list(x = 0)
class(p)
class(p1)
typeof(p1)
is.object(p)
is.object(p1)
class(class)
typeof(class)
typeof(vector3D)
ftype(p)
ftype(vector3D)
sloop::ftype(vector3D)
print(p)
print(unclass(p))
print.factor()
print.factor(factor(c("1")))
print.factor((c("1")))
rm(list = ls())
new_vector3D <- function(x1 = 0, y1 = 0, z1 = 0){
value <- list(x = x1, y = y1, z = z1)
class(value) = "vector3D"
value
}
p <- new_vector3D(x1 = "hmm")
p
a <- 0
class(c)
class(a)
rm(list = ls())
new_vector3D <- function(x1 = 0, y1 = 0, z1 = 0){
stopifnot(is.numeric(x1) && is.numeric(y1) && is.numeric(z1))
value <- list(x = x1, y = y1, z = z1)
class(value) = "vector3D"
value
}
p <- new_vector3D()
p <- new_vector3D(x = "hmm")
genfun <- function(x){
UseMethod("genfun")
}
genfun.numeric <- function(x){
print("numeric")
}
genfun.default <- function(x){
print("default")
}
genfun(1)
genfun("hello")
?useMethod
??useMethod
genfun <- function(x,y){
UseMethod("genfun",y)
}
genfun("hello", 1)
genfun(y = 1)
genfun <- function(x,y){
UseMethod("genfun",y)
}
genfun <- function(x,y){
UseMethod("genfun","y")
}
genfun(y = 1)
genfun(1,1)
rm(list = ls())
genfun(1,1)
genfun <- function(x,y){
UseMethod("genfun",y)
}
genfun.numeric <- function(x){
print("numeric")
}
genfun.default <- function(x){
print("default")
}
genfun(1,1)
genfun(1,1)
genfun.numeric <- function(x,y){
print("numeric")
}
genfun.default <- function(x,y){
print("default")
}
genfun(1,1)
genfun("hi",1)
genfun("hi","hi")
genfun(1,"hi")
rm(list = ls())
cross_product(a,b){
stopifnot(class(a)=="vector3D" && class(b)=="vector3D")
}
cross_product <- function(a,b){
stopifnot(class(a)=="vector3D" && class(b)=="vector3D")
}
p1 <- new_vector3D(4,5)
new_vector3D <- function(x1 = 0, y1 = 0, z1 = 0){
stopifnot(is.numeric(x1) && is.numeric(y1) && is.numeric(z1))
value <- list(x = x1, y = y1, z = z1)
class(value) = "vector3D"
value
}
p1 <- new_vector3D(4,5)
p2 <- new_vector3D()
p3 <- list(x=0)
cross_product(p1,p2)
cross_product(p1,p3)
?print
print.vector3D <- print(x, ...){
print("vector3D")
}
print.vector3D <- function(x, ...){
print("vector3D")
}
print(p1)
print.vector3D <- function(x, ...){
print("X: " + x$x + ", Y: " + x$y + ", Z: " + x$z)
}
print(p1)
print.vector3D <- function(x, ...){
paste("X: ",x$x,", Y: ",x$y,", Z: ",x$z)
}
print(p1)
new_vector3D <- function(x1 = 0, y1 = 0, z1 = 0){
stopifnot(is.numeric(x1) && is.numeric(y1) && is.numeric(z1))
value <- list(x = x1, y = y1, z = z1)
class(value) = "vector3D"
value
}
cross_product <- function(a,b){
stopifnot(class(a)=="vector3D" && class(b)=="vector3D")
#Z axis of the two vectors are guaranteed to be zero
c_z <- (a$x*b$y - b$x*a$y)
c <- new_vector3D(0,0,c_z)
c
}
#' print() for the vector3D class
print.vector3D <- function(x, ...){
paste("X: ",x$x,", Y: ",x$y,", Z: ",x$z)
}
p1 <- new_vector3D(1,1,0)
p2 <- new_vector3D(-1,1,0)
p3 <- cross_product(p1,p2)
print(p3)
p3 <- new_vector3D()
is_left_of(p1,p2,p3)
#returns true if c is to the left of a->b vector
is_left_of <- function(a,b,c){
stopifnot(class(a)=="vector3D" && class(b)=="vector3D" && class(c)=="vector3D")
#a->b vector
ab <- new_vector3D(b$x-a$x,b$y-a$y,b$z-a$z)
#a->c vector
ac <- new_vector3D(c$x-a$x,c$y-a$y,c$z-a$z)
return(cross_product(ab,ac) > 0)
}
is_left_of(p1,p2,p3)
#returns true if c is to the left of a->b vector
is_left_of <- function(a,b,c){
stopifnot(class(a)=="vector3D" && class(b)=="vector3D" && class(c)=="vector3D")
#a->b vector
ab <- new_vector3D(b$x-a$x,b$y-a$y,b$z-a$z)
#a->c vector
ac <- new_vector3D(c$x-a$x,c$y-a$y,c$z-a$z)
return(cross_product(ab,ac)$z > 0)
}
is_left_of(p1,p2,p3)
#returns true if c is to the left of a->b vector
is_left_of <- function(a,b,c){
stopifnot(class(a)=="vector3D" && class(b)=="vector3D" && class(c)=="vector3D")
#a->b vector
ab <- new_vector3D(b$x-a$x,b$y-a$y,b$z-a$z)
#a->c vector
ac <- new_vector3D(c$x-a$x,c$y-a$y,c$z-a$z)
cross_product(ab,ac)$z > 0
}
is_left_of(p1,p2,p3)
vignette("roxygen2")
roxygen2::roxygenise()
rm(list = ls())
roxygen2::roxygenise()
?new_vector3D
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
#' @title Constructor for the vector3D class
#'
#' @description An object of vector3D class has three values: x,y,z.
#' @param x1 The x value
#' @param y1 The y value
#' @param z1 The z value
new_vector3D <- function(x1 = 0, y1 = 0, z1 = 0){
stopifnot(is.numeric(x1) && is.numeric(y1) && is.numeric(z1))
value <- list(x = x1, y = y1, z = z1)
class(value) = "vector3D"
value
}
#' @title Cross Product of two vectors
#'
#' @description Calculates the Cross Product of two vector3D objects and returns a single vector3D object.
#' @param a First vector
#' @param b Second vector
cross_product <- function(a,b){
stopifnot(class(a)=="vector3D" && class(b)=="vector3D")
#Z axis of the two vectors are guaranteed to be zero
#resultant vector will only be along Z axis
c_z <- (a$x*b$y - b$x*a$y)
c <- new_vector3D(0,0,c_z)
c
}
#' @title Checks if a point lies strictly to the left of a line segment
#'
#' @description returns TRUE if point c lies strictly to the left of a->b vector.
#' @param a initial point of a->b vector
#' @param b final point of a->b vector
#' @param c Point whose relative position is to be calculated
is_left_of <- function(a,b,c){
stopifnot(class(a)=="vector3D" && class(b)=="vector3D" && class(c)=="vector3D")
#a->b vector
ab <- new_vector3D(b$x-a$x,b$y-a$y,b$z-a$z)
#a->c vector
ac <- new_vector3D(c$x-a$x,c$y-a$y,c$z-a$z)
cross_product(ab,ac)$z > 0
}
#' @title print() function for vector3D class
#'
#' @description An S3 method using the print() generic
#'
#' @param x A vector3D object
#' @param ... Additional arguments
#' @examples
#' print(new_vector(5,2,5))
print.vector3D <- function(x, ...){
paste("X: ",x$x,", Y: ",x$y,", Z: ",x$z)
}
devtools::check()
rm(list = ls())
roxygen2::roxygenise
roxygen2::roxygenise()
devtools::check()
devtool::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
?T
help(tripack)
install.packages("tripack")
help(tripack)
library(tripack)
help(tripack)
??tripack
man(tripack)
?tripack::add.constraint()
?tripack::circles()
x <- rnorm(10)
y <- rnorm(10)
r<-runif(10,0,0.5)
plot(x,y)
tripack::circles(x,y,r)
plot(x,y,xlim = c(-3,3), ylim = c(-3,3))
tripack::circles(x,y,r)
plot(x,y,xlim = c(-3,3), ylim = c(-3,3), pch = "+")
tripack::circles(x,y,r)
length(3)
x <- c(0)
y <- c(0)
r = 1
r <- c(1)
circles(x,y,r)
plot()
rm.plot
phi <- seq(0,2*pi,360)
phi
phi <- seq(0,2*pi,length = 360)
phi
phi <- seq(0,2*pi,360)
phi
phi <- seq(0,2*pi,length = 360)
cp <- cos(phi)
cp
r <- 5
rcp <- r* cp
rcp
x <- 1
xrcp <- x + rcp
xrcp
?lines
# center (a,b) circle (x=a+r*theta, y=b+r*theta) theta = [0,2pi]
circle <- function(a,b,r,...){
angle <- seq(0,2*pi,length = 360)
x <- a + r*angle
y <- b + r*angle
lines(x,y)
}
circle(0,0,1)
# center (a,b) circle (x=a+r*theta, y=b+r*theta) theta = [0,2pi]
circle <- function(a,b,r,...){
angle <- seq(0,2*pi,length = 360)
angle
x <- a + r*angle
x
y <- b + r*angle
y
}
circle(0,0,1)
# center (a,b) circle (x=a+r*cos(theta), y=b+r*sin(theta) ) theta = [0,2pi]
circle <- function(a,b,r,...){
angle <- seq(0,2*pi,length = 360)
x <- a + r*cos(angle)
y <- b + r*sin(angle)
lines(x,y)
}
circle(0,0,1)
plot(5,5)
circle(0,0,5)
circle(5,5,1)
?tripack::circles()
x<-rnorm(10)
y<-rnorm(10)
r <- runif(10,0,0.5)
plot(x,y,xlim = c(-3,3), ylim = c(-3,3), pch = "+")
circles(x,y,r)
plot(x,y,xlim = c(-3,3), ylim = c(-3,3), pch = ".")
circles(x,y,r)
knitr::opts_chunk$set(echo = TRUE)
library(fitzRoy)
library(dplyr)
library(interp)
library(tripack)
# Get data and find scatter plot that is instant and long scatter plot
aflw <- fetch_player_stats(2020, comp = "AFLW")
aflw_num <- aflw %>%
select_if(is.numeric)
aflw_num <- aggregate(aflw_num[,5:37],
list(aflw$player.player.player.surname),
mean)
# three vectors (one is problems)
a <- aflw_num$goals
b <- aflw_num$behinds
c <- aflw_num$handballs
# get ac to shull input
#inside cassowaryr::scree()
ac <- cbind(cassowaryr:::unitize(a), cassowaryr:::unitize(c))
install.packages("cassowaryr")
# get ac to shull input
#inside cassowaryr::scree()
ac <- cbind(cassowaryr:::unitize(a), cassowaryr:::unitize(c))
library(cassowaryr)
rm(list = ls())
data <- datasauRus::datasaurus_dozen
data
dino <- data[[dataset="dino"]]
dino <- data[dataset="dino"]
dino
tri.obj1 <- tripack::tri.mesh(dino$x,dino$y)
plot(tri.obj1)
tri.obj1 <- tripack::tri.mesh(dino$x,dino$y, pch = ".")
tri.obj1 <- tripack::tri.mesh(dino$x,dino$y, tch = ".")
tri.obj1 <- tripack::tri.mesh(dino$x,dino$y, pch = ".")
plot(tri.obj1, pch = ".")
tri.obj1
tripack::add.constraint(tri.obj1)
?tripack::add.constraint
?tripack::add.constraint
data(tritest)
library(tripack)
data(tritest)
tritest.tr <- tri.mesh(tritest)
plot(tritest.tr)
tritest2 <- tritest.tr
opar <- par(mfrow = c(2,2))
opar
tritest2 <- add.constraint(tritest.tr, c(-1,2,-1),c(-3,0.5,3))
tritest2 <- add.constraint(tritest.tr, c(-1,2,-1),c(-3,0.5,3), reverse = TRUE)
plot(tritest2)
tritest2 <- add.constraint(tritest.tr, c(0.4, 0.4,0.6,0.6), c(0.6,0.4,0.4,0.6), reverse = FALSE)
plot(tritest2)
plot(tritest.tr)
View(opar)
rm(list = opar)
rm(list = c(opar)
)
rm(list = c("opar"))
plot(tritest2)
par(mar = c(1,1,1,1))
plot(tritest2)
plot(tritest.tr)
tritest2 <- add.constraint(tritest.tr, c(-1,2,-1),c(-3,0.5,3), reverse = TRUE)
plot(tritest2)
tritest2 <- add.constraint(tritest.tr, c(0.4, 0.4,0.6,0.6), c(0.6,0.4,0.4,0.6), reverse = FALSE)
plot(tritest2)
plot(tritest2)
par(mar = c(1,1,1,1))
plot(tritest2)
tritest2 <- add.constraint(tritest.tr, c(0.4, 0.4,0.6,0.6), c(0.6,0.4,0.4,0.6), reverse = TRUE)
plot(tritest.tr, title = "standard")
par(mar = c(1,1,1,1))
plot(tritest.tr, title = "standard")
?interp::add.constraint
?interp::tri.mesh
