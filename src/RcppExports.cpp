// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include <Rcpp.h>

using namespace Rcpp;

#ifdef RCPP_USE_GLOBAL_ROSTREAM
Rcpp::Rostream<true>&  Rcpp::Rcout = Rcpp::Rcpp_cout_get();
Rcpp::Rostream<false>& Rcpp::Rcerr = Rcpp::Rcpp_cerr_get();
#endif

// GetMatrix
NumericMatrix GetMatrix(std::vector<std::vector<int>> m);
RcppExport SEXP _triad_GetMatrix(SEXP mSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::vector<std::vector<int>> >::type m(mSEXP);
    rcpp_result_gen = Rcpp::wrap(GetMatrix(m));
    return rcpp_result_gen;
END_RCPP
}
// Edge
int Edge(int I, int J, std::vector<std::vector<int>> e);
RcppExport SEXP _triad_Edge(SEXP ISEXP, SEXP JSEXP, SEXP eSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< int >::type I(ISEXP);
    Rcpp::traits::input_parameter< int >::type J(JSEXP);
    Rcpp::traits::input_parameter< std::vector<std::vector<int>> >::type e(eSEXP);
    rcpp_result_gen = Rcpp::wrap(Edge(I, J, e));
    return rcpp_result_gen;
END_RCPP
}
// LeftRight
double LeftRight(double Px, double Py, double Ax, double Ay, double Bx, double By);
RcppExport SEXP _triad_LeftRight(SEXP PxSEXP, SEXP PySEXP, SEXP AxSEXP, SEXP AySEXP, SEXP BxSEXP, SEXP BySEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< double >::type Px(PxSEXP);
    Rcpp::traits::input_parameter< double >::type Py(PySEXP);
    Rcpp::traits::input_parameter< double >::type Ax(AxSEXP);
    Rcpp::traits::input_parameter< double >::type Ay(AySEXP);
    Rcpp::traits::input_parameter< double >::type Bx(BxSEXP);
    Rcpp::traits::input_parameter< double >::type By(BySEXP);
    rcpp_result_gen = Rcpp::wrap(LeftRight(Px, Py, Ax, Ay, Bx, By));
    return rcpp_result_gen;
END_RCPP
}
// Swap
bool Swap(double x1, double y1, double x2, double y2, double x3, double y3, double xp, double yp);
RcppExport SEXP _triad_Swap(SEXP x1SEXP, SEXP y1SEXP, SEXP x2SEXP, SEXP y2SEXP, SEXP x3SEXP, SEXP y3SEXP, SEXP xpSEXP, SEXP ypSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< double >::type x1(x1SEXP);
    Rcpp::traits::input_parameter< double >::type y1(y1SEXP);
    Rcpp::traits::input_parameter< double >::type x2(x2SEXP);
    Rcpp::traits::input_parameter< double >::type y2(y2SEXP);
    Rcpp::traits::input_parameter< double >::type x3(x3SEXP);
    Rcpp::traits::input_parameter< double >::type y3(y3SEXP);
    Rcpp::traits::input_parameter< double >::type xp(xpSEXP);
    Rcpp::traits::input_parameter< double >::type yp(ypSEXP);
    rcpp_result_gen = Rcpp::wrap(Swap(x1, y1, x2, y2, x3, y3, xp, yp));
    return rcpp_result_gen;
END_RCPP
}
// TriLoc
int TriLoc(int i, std::vector<double> x, std::vector<double> y, std::vector<std::vector<int>> v, std::vector<std::vector<int>> e);
RcppExport SEXP _triad_TriLoc(SEXP iSEXP, SEXP xSEXP, SEXP ySEXP, SEXP vSEXP, SEXP eSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< int >::type i(iSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type x(xSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type y(ySEXP);
    Rcpp::traits::input_parameter< std::vector<std::vector<int>> >::type v(vSEXP);
    Rcpp::traits::input_parameter< std::vector<std::vector<int>> >::type e(eSEXP);
    rcpp_result_gen = Rcpp::wrap(TriLoc(i, x, y, v, e));
    return rcpp_result_gen;
END_RCPP
}
// test_TriLoc
int test_TriLoc(int i, NumericVector x, NumericVector y, NumericMatrix v, NumericMatrix e);
RcppExport SEXP _triad_test_TriLoc(SEXP iSEXP, SEXP xSEXP, SEXP ySEXP, SEXP vSEXP, SEXP eSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< int >::type i(iSEXP);
    Rcpp::traits::input_parameter< NumericVector >::type x(xSEXP);
    Rcpp::traits::input_parameter< NumericVector >::type y(ySEXP);
    Rcpp::traits::input_parameter< NumericMatrix >::type v(vSEXP);
    Rcpp::traits::input_parameter< NumericMatrix >::type e(eSEXP);
    rcpp_result_gen = Rcpp::wrap(test_TriLoc(i, x, y, v, e));
    return rcpp_result_gen;
END_RCPP
}
// Delaun
NumericMatrix Delaun(NumericVector norm_x, NumericVector norm_y);
RcppExport SEXP _triad_Delaun(SEXP norm_xSEXP, SEXP norm_ySEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< NumericVector >::type norm_x(norm_xSEXP);
    Rcpp::traits::input_parameter< NumericVector >::type norm_y(norm_ySEXP);
    rcpp_result_gen = Rcpp::wrap(Delaun(norm_x, norm_y));
    return rcpp_result_gen;
END_RCPP
}
// timesTwo
NumericVector timesTwo(NumericVector x);
RcppExport SEXP _triad_timesTwo(SEXP xSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< NumericVector >::type x(xSEXP);
    rcpp_result_gen = Rcpp::wrap(timesTwo(x));
    return rcpp_result_gen;
END_RCPP
}

static const R_CallMethodDef CallEntries[] = {
    {"_triad_GetMatrix", (DL_FUNC) &_triad_GetMatrix, 1},
    {"_triad_Edge", (DL_FUNC) &_triad_Edge, 3},
    {"_triad_LeftRight", (DL_FUNC) &_triad_LeftRight, 6},
    {"_triad_Swap", (DL_FUNC) &_triad_Swap, 8},
    {"_triad_TriLoc", (DL_FUNC) &_triad_TriLoc, 5},
    {"_triad_test_TriLoc", (DL_FUNC) &_triad_test_TriLoc, 5},
    {"_triad_Delaun", (DL_FUNC) &_triad_Delaun, 2},
    {"_triad_timesTwo", (DL_FUNC) &_triad_timesTwo, 1},
    {NULL, NULL, 0}
};

RcppExport void R_init_triad(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
